<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css"
  integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"
  integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js"
  integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: "\\begin{equation}", right: "\\end{equation}", display: true },
        { left: "\\begin{equation*}", right: "\\end{equation*}", display: true },
        { left: "\\begin{align}", right: "\\end{align}", display: true },
        { left: "\\begin{align*}", right: "\\end{align*}", display: true },
        { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
        { left: "\\begin{gather}", right: "\\end{gather}", display: true },
        { left: "\\begin{CD}", right: "\\end{CD}", display: true },
      ],
      throwOnError: false,
      trust: (context) => ['\\htmlId', '\\href'].includes(context.command),
      macros: {
        "\\eqref": "\\href{###1}{(\\text{#1})}",
        "\\ref": "\\href{###1}{\\text{#1}}",
        "\\label": "\\htmlId{#1}{}"
      }
    });
  });
</script>

<script>
  var sTag;
  var labelTagArr = [];
  window.addEventListener("load", function () {
    try {
      // KaTeX doesn't support \ref or \eqref when paired with \label or \tag.
      // This hack gets them to work and provides a link from \ref and \eqref to the equation.
      // DIV that contains math:
      var demo = document.querySelector("#demo");
      // Remove line breaks to make life easier; and
      // Javascript 'helpfully' converts "&" into "&amp;", so we temporarily set them to redeemable gibberish
      demo.innerHTML = demo.innerHTML.replace(/\n/g, " ").replaceAll('&', "notAmpersand");
      // Javascript is not happy with : in an ID, so we replace each one with -cln-
      demo.innerHTML = demo.innerHTML.replaceAll('eq:', "eq-cln-");
      // For eqref numbering (or not):
      var numberedEnvironmentsArr = ['equation', 'align', 'gather', 'alignat'];
      // For \eqref's and \ref's later
      var eqrefNum = 0;
      // For keeping track of eqref ->  for later use
      var aTagArr = [];
      // Find all environments
      // \2 is the reference to the 2nd capture group (the environment name)
      var eqnPattern = /(\\begin\{(.*?)\}(.*?)\\end\{\2\})/gm;
      ///////////////////////////////////////
      //
      // Loop through ENVIRONMENTS
      //
      //////////////////////////////////////
      var eqnIndex = 0;
      while (eqnMatches = eqnPattern.exec(demo.innerHTML)) {
        var arrayFromEqnMatches = Array.from(eqnMatches);
        // The full environment expression
        var eqn = arrayFromEqnMatches[0];
        // The environment (equation, array, etc)
        var env = arrayFromEqnMatches[2];
        // The inner text of the environment
        var eqnTxt = arrayFromEqnMatches[3];
        // Determine if equations are going to mess up numbering & trigger error
        var countSlashes = (eqnTxt.match(/\\\\/gi) || []).length;
        var countLabels = (eqnTxt.match(/\\label/gi) || []).length;
        var countNonumbers = (eqnTxt.match(/\\nonumber/gi) || []).length;
        var countTags = (eqnTxt.match(/\\tag/gi) || []).length;
        var countSplits = (eqnTxt.match(/\\begin\{split\}/gi) || []).length;
        if (
          (!numberedEnvironmentsArr.includes(env)) ||
          (countSplits > 0 && countSlashes == countSplits) ||
          (countSlashes == 0 && countLabels == 0 && countNonumbers == 0 && countTags == 0 && countSplits == 0)
        ) {
          // All OK. Continue...
        } else if (
          (countTags == 1 && countNonumbers < countSlashes) ||
          (countTags == 0 && countSlashes + 1 > countLabels + countNonumbers)
        ) {
          // Wrap errant equation in a span and give feedback
          var sTag = document.createElement('span');
          sTag.classList.add('dunProcess');
          sTag.innerHTML = eqn.replaceAll('\\\\', "\\\\
").replace('\\end', "
            \\end");
                demo.innerHTML = demo.innerHTML.replace(eqn, sTag.outerHTML);
        }
        // If numbered environment
        if (numberedEnvironmentsArr.includes(env)) {
          eqrefNum++;
        }
        ///////////////////////////////////////
        //
        // Loop through LABELs and/or TAGs
        //
        //////////////////////////////////////
        var labelTagPattern = /((\\tag)|(\\label))\{([^}]+)\}/gm;
        // Get labelTag outer and inner
        var labelTagMatches = eqn.matchAll(labelTagPattern);
        var labelTag, labelTagTxt, labelTagType;
        labelTagArr[eqnIndex] = [];
        aTagArr[eqnIndex] = [];
        // Loop through all the label and tag matches      
        labelTagMatches.forEach(function (labelTagMatch, i) {
          labelTag = labelTagMatch[0];
          labelTagType = labelTagMatch[1].slice(1);
          labelTagTxt = labelTagMatch[4];
          // Save the tags for use later
          labelTagArr[eqnIndex].push(labelTagTxt);
          if (labelTagType == "label") {
            if (labelTagArr[eqnIndex].length > 1) {
              eqrefNum++;
            }
            aTagHref = '#ktx-' + labelTagTxt;
          } else if (labelTagType == "tag") {
            aTagHref = '#ktx-' + labelTagTxt;
          }
          // Already incremented equation number for numbered environment,
          // so undo it here for split case
          if (eqn.indexOf('\\begin{split}') > -1) {
            eqrefNum--;
          }
          // Create  tag for \eqref's array for use later
          var aTag = document.createElement('a');
          aTag.href = aTagHref
          var anchorTxt;
          if (numberedEnvironmentsArr.includes(env) && labelTagType == "label") {
            anchorTxt = eqrefNum;
          } else {
            anchorTxt = labelTagTxt;
          }
          if (demo.innerHTML.indexOf("\\eqref{" + labelTagTxt + "}") > -1) {
            aTag.innerText = '(' + anchorTxt + ')';
            // Add eqref's to array for replacing later with links
            aTagArr[eqnIndex].push(["\\eqref{" + labelTagTxt + "}", aTag.outerHTML]);
          }
          if (demo.innerHTML.indexOf("\\ref{" + labelTagTxt + "}") > -1) {
            aTag.innerText = anchorTxt;
            // Add ref's to array for replacing later with links
            aTagArr[eqnIndex].push(["\\ref{" + labelTagTxt + "}", aTag.outerHTML]);
          }

        }); // end of labels and tags
        // Increment the equation index
        eqnIndex++;
      } // End of ENVs    

      // Set back the ampersands to normal, ready for KaTeX processing:
      demo.innerHTML = demo.innerHTML.replaceAll('notAmpersand', '&');


      // Find any \eqref's that don't have a real equation to point to
      var eqrefPattern = /\\eqref\{([^}]+)\}/gm;
      var eqrefMatches = demo.innerHTML.matchAll(eqrefPattern);
      for (let eqrefMatch of eqrefMatches) {
        if (
          demo.innerHTML.indexOf('\\label{' + eqrefMatch[1]) > -1
          || demo.innerHTML.indexOf('\\tag{' + eqrefMatch[1]) > -1
        ) {
          //nothing
        } else {
          var sTag = document.createElement('span');
          sTag.classList.add('missing');
          sTag.innerHTML = "no equation matching this \\eqref{" + eqrefMatch[1] + "}";
          // Update the HTML
          if (!!sTag) {
            demo.innerHTML = demo.innerHTML.replace(eqrefMatch[0], sTag.outerHTML);
          }
        }
      }
      // Remove the labels so they don't trigger KaTeX errors
      labelTagArr.forEach(function (labelTags, i) {
        labelTags.forEach(function (labelTag, j) {
          if (labelTag != "ellippolar") {
            demo.innerHTML = demo.innerHTML.replaceAll('\\label{' + labelTag + '}', '');
          }
        });
      });

      // Now render the modified demo node with KaTeX
      // Delimiters array
      var objArr = [{
        left: "$",
        right: "$",
        display: !1
      }, {
        left: "\\(",
        right: "\\)",
        display: !1
      }, {
        left: "\\[",
        right: "\\]",
        display: !0
      }];
      var displayEnvsArr = ["\$\$", "align", "align*", "alignat", "CD", "equation", "equation*", "gather", "matrix", "pmatrix", "Vmatrix"];
      displayEnvsArr.forEach(function (env) {
        objArr.push({
          left: "\\begin{" + env + "}",
          right: "\\end{" + env + "}",
          display: !0
        });
      });
      // Now do KaTeX rendering
      renderMathInElement(demo, {
        delimiters: objArr,
        ignoredClasses: ['dunProcess'],
        throwOnError: false
      });
      // Loop through all the display-mode spans (environments)
      var katexDisplays = document.querySelectorAll('.katex-display');
      katexDisplays.forEach(function (katexDisplay, i) {
        if (labelTagArr[i].length == 1) {
          // One equation only in display mode:
          // Apply id to display mode span        
          katexDisplay.id = 'ktx-' + labelTagArr[i];
        } else if (labelTagArr[i].length > 1) {
          // More than one line in display mode with labels for each
          // Loop through and apply id to the equation numbers
          // Add a scroll margin so we land a bit above 
          // the equation number for better usability        
          var eqnNums = katexDisplay.querySelectorAll('.eqn-num');
          eqnNums.forEach(function (eqnNum, j) {
            eqnNum.id = "ktx-" + labelTagArr[i][j];
          });
        }
      });
      // Loop through aTagArr and replace eqrefs and refs in document with  tags
      aTagArr.forEach(function (aTags, i) {
        if (aTags) {
          aTags.forEach(function (aTagPair, j) {
            demo.innerHTML = demo.innerHTML.replaceAll(aTagPair[0], aTagPair[1]);
          });
        }
      });
      // Add smooth scrolling for new links
      var theAtags = document.querySelectorAll('a[href*="#ktx-');
      theAtags.forEach(function (theAtag) {
        theAtag.addEventListener('click', function (e) {
          e.preventDefault();
          document.querySelector(this.getAttribute('href')).scrollIntoView({
            behavior: 'smooth'
          });
        });
      });
    } catch (e) {
      if (e instanceof katex.ParseError) {
        // KaTeX can't parse the expression
        html = ("Error in LaTeX '" + texString + "': " + e.message)
          .replace(/&/g, "&").replace(//g, ">");
        } else {
        throw e; // other error
      }
    }
    addOverflowXauto();
  });
  // Add class to allow horizontal scroll on wide elements for phones
  var addOverflowXauto = function () {
    var browserWidth = Math.max(
      document.body.scrollWidth,
      document.documentElement.scrollWidth,
      document.body.offsetWidth,
      document.documentElement.offsetWidth,
      document.documentElement.clientWidth
    );
    var eles = document.querySelectorAll(".katex");
    eles.forEach(function (ele) {
      var thisEleWidth = ele.scrollWidth;
      if (thisEleWidth > browserWidth && !ele.parentNode.classList.contains('overflowXauto')) {
        ele.parentNode.classList.add('overflowXauto');
      }
    });
  }
  window.addEventListener('resize', function () {
    addOverflowXauto();
  });
</script>